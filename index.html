<!DOCTYPE >
<html>

<head>
  <title>Welcome to My First Web Page</title>
</head>
<a href="bonus.html">BONUS</a>
<body>
<h6>Melbourne :Australia</h6>
<p>Melbourne is one of the best place for Nature lovers. <b>Melbourne’s 
    winding alleyways are magical;</b>  they’ll probably make you feel as though
    you’ve stepped <b>into a real-life Wonderland</b>. The city is well-known across Australia for its 
    vibrant laneway culture, which is brimming with bustling shopping arcades, wandering musicians, 
    live music, quiet street-side book cafes… and the occasional secret street party.  Melbourne is the most liveable city in the
    world! Out of 140 places, Victoria's capital was voted as the most awesome place to live.  
    There is no other place on the entire planet that provides a better living standard than good old Melbourne.
    The five main categories were stability, health care, culture, environment, education and infrastructure. 
</p>
<hr>
<h3>Directions to My Favourite Place</h3>
<ol>
   <li> Book a ride from Mayville to Kansas City Airport.</li>
   <li>Then book a best flight based on iternary from kanas to Melbourne as it takes long time to travel</li>
   <ol>
       <li>Pack all the necessary items for Travelling.</li>
       <li>Make Sure to reach the Airport before three hours of departure time.</li>
       <li>Once reaching Melbourne Airport take a ride to Victoria.</li>
       <li>After Reaching Victoria take a motel to stay until your trip.</li>
   </ol>
   <li>Finally Reached at your Favourite Place.</li>
   </ol>
   <ul>
       <li>Below are the foods that are bought to my favourite place</li>
       <li>Meat</li>
       <li>Alcohol</li>
       <li>Playing Cards</li>
       <li>Food</li>
       <li>CampFire</li>
    </ul>
    <a href=aboutme.html> Link to AboutMe File</a>

<hr>
<h1>Table Creation using HTML</h1>
<p>Below Table describles the food items that someone must try. 
    The Table consists of name of food items and the place where these items will be 
    avalible and then cost of the particular food item.</p>
    <style>
        table, th, td {
          border: 1px solid black;
          border-collapse: collapse;
        }
        </style>

    <table>
        <tr>
            <th>Name of Food Item</th>
            <th>Location</th>
            <th>Cost of Food Item</th>
        </tr>
        <tr>
        <td>Biryani</td>
        <td>Hyderabad</td>
        <td>$30</td>
        </tr>
        <tr>
            <td>Momos</td>
            <td>Kolkata</td>
            <td>$10</td>
        </tr>
        <tr>
            <td>Pani Puri</td>
            <td>Maharashtra</td>
            <td>$5</td>
        </tr>
        <tr>
            <td>Fish Fry</td>
            <td>Kolkata</td>
            <td>$25</td>
        </tr>
    </table>
    <br>
    <hr>
    <h1>Blockquote using HTML</h1>
  <blockquote cite="https://iq.opengenus.org/binary-lifting-k-th-ancestor-lowest-common-ancestor/">
    Lifting is a technique used to find the k-th ancestor of any node in a tree in O(logn). 
    This also leads to a faster algorithm in finding the lowest common ancestor (LCA) between two nodes in a tree. 
    It can also be used to compute functions such as minimum, maximum and sum between two nodes of a tree in logarithmic time. 
    The technique requires preprocessing the tree in O(N log N) using dynamic programming.
      The first step is to find out the 2j ancestor of every node where 0 <= j <= log(n).
       This can be done by dynamic programming</blockquote>
       <a href="https://iq.opengenus.org/binary-lifting-k-th-ancestor-lowest-common-ancestor/">Link to Source File</a>

       <pre>
           int n, l;
        vector<vector<int>> adj;
        
        int timer;
        vector<int> tin, tout;
        vector<vector<int>> up;
        
        void dfs(int v, int p)
        {569]
            tin[v] = ++timer;
            up[v][0] = p;
            for (int i = 1; i <= l; ++i)
                up[v][i] = up[up[v][i-1]][i-1];
        
            for (int u : adj[v]) {
                if (u != p)
                    dfs(u, v);
            }
        
            tout[v] = ++timer;
        }
        
        bool is_ancestor(int u, int v)
        {
            return tin[u] <= tin[v] && tout[u] >= tout[v];
        }
        
        int lca(int u, int v)
        {
            if (is_ancestor(u, v))
                return u;
            if (is_ancestor(v, u))
                return v;
            for (int i = l; i >= 0; --i) {
                if (!is_ancestor(up[u][i], v))
                    u = up[u][i];
            }
            return up[u][0];
        }
        
        void preprocess(int root) {
            tin.resize(n);
            tout.resize(n);
            timer = 0;
            l = ceil(log2(n));
            up.assign(n, vector<int>(l + 1));
            dfs(root, root);
        }
    </pre>
</body>
</html>